== Question 1: ==

For string t to be constructed using letters in string s,
the occurrence of each letter in t must not exceed its counterpart
in s.
To count the occurrence of letters, I utilize the Counter object.
If string s contains all letters of string t, after subtracting the 
letter count of t from letter count of s, there should not be any
negative counts.

Time Complexity:
n = length of s, m = length of t
Since the Counter object needs to iterate through the string to 
count occurrence, each counter would require a linear time operation 
(O(n+m)). Each operation on a counter element is constant time. The 
subtract method iterate through elements in the t string counter. So 
in the worst case, it would be linear time in respect to length of t 
(O(m)). Finally, to check for negative count, the worst case is that 
all letters in s are unique (O(n)).
Combining all the above, the time complexity would be O(2n+2m) which 
simplifies to O(n+m).

Space Complexity:
The initial input will take n, and m amount of space. If both strings 
only contains unique letters, each counter will also take linear 
amount of space. This means the space complexity is also O(n+m).


== Question 2: ==

The rationle behind this approach is that for a string to be a 
pallendron, its substring without the first and last character must 
also be a pallendron. So I want to make a table indicating pallendron 
substrings.
Table:
   | 0 | 1 | 2 | 3 | 4
---+---+---+---+---+----
 0 | T |   |   |   |
---+---+---+---+---+----
 1 |   | T |   |   |
---+---+---+---+---+----
 2 |   |   | T |   |
---+---+---+---+---+---- 
 3 |   |   |   | T |
---+---+---+---+---+---- 
 4 |   |   |   |   | T

This table needs to be filled in the order of shortest substring 
length, so the longer substrings could referce when checking.
Whenever a pallendron is found, if it is longer than the previous 
substring, the max length and start index would be updated. Once the 
table is filled, the the max length and start index would indicate 
the longest pallendron substring.

Time Complexity:
Filling each cell of the table is constant time.
For string length n, the number of cells need to be filled is 
n(n+1)/2. Which simplifies to O(n^2).

Space Complexity:
For string length n, the table will take n^2 space. The input string 
takes n space. O(n^2+n) simplifies to O(n^2).


== Question 3: ==

Since this is a minimum spanning tree, a greedy algorithm seems like 
a good approach. I will keep selecting the shortest edge that 
connects to a new vertex until all vertices have been included. 
To get the shortest edge, I would want to construct a sorted edge 
list. As the input is an adjacency list, the edges are listed twice. 
Therefore I use a set to make sure I am not counting duplicates. 

Time Complexity:
When choosing edges, worst case, each edge gets visited once. O(E)
When constructing list of edges, each vertex gets visited once. O(V)
When sorting edges, python's sort method has efficiency of O(ElogE)
The overall efficiency would be the major contributor O(ElogE).

Space Complexity:
As mentioned before, in an adjacency list, each edge is listed twice. 
The edges set contains each edge once. Both are linearly relate to 
number of edges. Therefore space complexity would be O(E).


== Question 4: ==

Since the input is a BST, the least common ancestor is the node 
that has either 1) the two test node on either side or 2) is one 
of the test nodes.  Therefore I can use a recursive function with 
those two conditions as base cases. If the base cases are not met, 
the function should look for the child nodes of the root node. 
Depending on which side the test nodes are, the function will take 
the left or right child node as the root node and run again.

Time Complexity:
In each recursion, the function will loop through one row of the 
matrix. Since the matrix is a adjacency matrix, the length of the 
matrix is the number of nodes in the tree.
In the worst case, the number of recursions will be one less than 
the depth of the tree. Since it is not nessisary a balanced BST, 
the depth of the tree could be the number of nodes.
The worst case time complexity approximates to O(n^2)

Space Complexity:
Since the function does not create a new data structure. The space 
complexity would be the original matrix, which would be O(n^2) for 
n nodes.


== Question 5: ==

There are two different approach to this problem. I could either 
iterate through the linked list twice; once to count and once to get 
the node I want. Or I can store the nodes in an array and have 
constant time lookup. I opted for time efficiency over space 
efficiency.
I iterate through the list, putting each node in a list. Then just 
subtract the mth number from the length of the list to get the index 
the targeted item.

Time Complexity:
Because I'm iterating through the list once, the time complexity is 
O(n) where n is the length of the linked list.

Space Complexity:
As a trade off of not iterating through the list twice, a new data 
structure is created. Therefore the space complexity is O(n^2).
